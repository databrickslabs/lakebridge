package com.databricks.labs.remorph.preprocessors.jinja

import com.databricks.labs.remorph.utils.Sed

case class TemplateManager(templates: Map[String, TemplateElement] = Map.empty) {

  def nextKey: String = {
    f"_!Jinja${templates.size + 1}%04d"
  }

  def add(key: String, template: TemplateElement): TemplateManager = {
    copy(templates = templates + (key -> template))
  }

  def get(key: String): Option[TemplateElement] = {
    templates.get(key)
  }

  /**
   * Replaces all the placeholders in the transpiler generated output with the actual
   * template values, taking care to observe whether the original template was space separated
   * or not - extra spaces generated by the transpiler will be removed when necessary.
   *
   * @param generated the output string we wish to rebuild with the original templates
   * @return the rebuilt output string
   */
  def rebuild(generated: String): String = {

    // Use the Sed utility to replace all the placeholders with the actual template values. We build
    // a regexp and a replacement string (which is just the template.text) for each template, the regex
    // is told to match and replace any preceding spaces if the template element was originally
    // not preceded by white space, and will match and replace trailing whitespace if it was not originally
    // followed by a whitespace. We use the resulting map to call the Sed utility to apply the
    // replacements. Note that we do not replace newlines as we need to preserve them so we
    // can preserve at least the rudimentary formatting of the generator output.
    val replacements: Seq[(String, String)] = templates.toSeq.map { case (key, template) =>
      (template.regex, template.text)
    } ++
      // In certain situations, these replacements will orphan trailing whitespace, which we remove with this regex
      Seq(("[ ]+\n", "\n"))
    val replace = new Sed(replacements: _*)
    replace(generated)
  }
}
